# ООП Семинар 11: Наследяване. Полиморфизъм

## Основи на наследяването

### Композиция срещу наследяване

#### Has-A връзка

```cpp
#include <string>

class Address {
    std::string street;
    std::string city;

public:
    Address(const std::string& s, const std::string& c);
    void displayAddress() const;
};

class Student {
    std::string name;
    int studentId;
    Address studentAddress;

public:
    Student(const std::string& n, int id, const std::string& s, const std::string& c);
    void displayStudentInfo() const;
};
```

В примера студентът ИМА адрес. При has-a връзките единият клас може да има множество представители от другия клас в себе си,
всеки със съответното име.

#### Is-A връзка

```cpp
#include <string>

class Person {
    std::string name;
    int age;

public:
    Person(const std::string& n, int a);
    void displayPersonInfo() const;
    const std::string& getName() const;
};

class Student : public Person {
    int studentId;

public:
    Student(const std::string& n, int a, int id);
    void displayStudentInfo() const;
};
```

В примера студентът Е човек (личност).

Когато използваме наследяване, получаваме възможност за автоматично преобразуване на указатели и референции
към базовия клас. Така например, ако имаме някакъв метод `vote(const Person& p)`, можем директно да му подадем
обект от тип студент, на който да бъде разглеждана „гражданската/човешката част“.

По този начин реализираме един от основните принципи на ООП, а именно преизползването.

### Видове наследяване -- private, protected, public

Таблица, която илюстрира как външиня свят вижда различните методи и полета спрямо достъпа им в базовия клас и
начина на наследяване:

| достъп в базов клас | public      | protected   | private     |
| ------------------- | ----------- | ----------- | ----------- |
| public              | public      | protected   | private     |
| protected           | protected   | protected   | private     |
| private             | Няма достъп | Няма достъп | Няма достъп |

Ако не кажем изрично модификатор за достъп при наследяване на даден клас, то се подразбира `private`. При структурите,
както там е public достъпа по принцип, така и наследяването е `public`, ако не кажем друго.

Когато наследяваме `private`, преобразуването на `Student` към `Person` е възможно само в private контекста на `Student`.

### Жизнен цикъл

#### При влагане

```cpp
class Base {
    int x;
    Inner i;

    Base() : i(5), x(3) {
        x++;
    }

    ~Base() {
        --x;
    }
}
```

Ред на изпълнение при създаване:

1. `x = 3;`
2. `Inner(5);`
3. `x++;`


Ред при унищожаване:

1. `--x;`
2. `~Inner();`
3. `~x` // Реално такъв деструктор няма

#### При наследяване

```cpp
class Derived : public Base {
    Inner i2;
    Base b; // няма проблеми да имаме както влагане, така и наследяване

    Derived() : Base(123) // Ако не се извика изрично конструктор на базовия клас,
        , i2(4)           // то се извиква този по подразбиране. Ако няма такъв,
        , b(10)           // то имаме компилационна грешка
    {
        doStuff();
    }

    ~Derived() {
        //...
    }
}
```

1. Извикват се конструкторите на базовите класове, в реда на наследяване;
2. Извикват се конструкторите на полетата в реда, в който са записани;
3. Изпълнява се `doStuff()`, тоест тялото на конструктора.

При унищожаване на обекта се изпълняват същите стъпки в точно обратен ред -- тяло на деструктора,
деструктори за членовете и накрая деструкторите за базовите класове.

Ако `Derived() = default`, то той първо извиква конструкторите по подразбиране на базовите класове,
после подразбиращите се за полетата.


#### Копиране и оператор= при наследяване

Ако използваме подразбиращ се копиращ конструктор или оператор=, то той ще извика съответните
подразбиращи се методи на базовите класове, а после и за членовете.

Ако си дефинираме наш:

```cpp
Derived(const Derived& other) {
    if(this != &other) {
        Base::operator=(d); // Преизползваме, а не пишем ръчно!
        //...
    }
    return *this;
}
```


### Overloading. Overriding. Статично свързване

#### Overloading

```cpp
class Base {
    //...

    void doSomething();

    void doSomething(int param);
}
```

Една и съща функция (същото име), но с различни параметри.

#### Overriding

```cpp
class Base {
    // ...

    void print() {
        std::cout << "Base" << std::endl;
    }
}

class Derived : public Base {
    // ...
    
    void print() {
        Base::print();
        std::cout << "Derived" << std::endl;
    }
}

int main() {
    Derived d;
    d.print(); // Derived::print()
    
    Base& b = d;
    b.print() // Base::print()
}
```

Пимерът отгоре илюстрира така нареченото преопределяне (overrding). В случая имаме **статично свързване**, тоест
по време на компилация се определя кой метод да бъде извикан в зависимост от типа.

## Полиморфизъм. Динамично свързване. Абстрактни класове.

### Динамично свързване и полиморфизъм

Полиморфизъм буквално означава „много форми“. Накратко, позволява ни даден код да има различно поведение,
в зависимост от това какъв обект се подава, без самия код явно да се променя.

Полиморфизъм вече сме виждали при функциите от по-висок ред.

Следния пример илюстрира полиморфно поведение, постигнато чрез **виртуални функции** и динамично свързване:

```cpp
class Shape {
public:
    virtual double getArea() const {
        std::cout << "Unknown shape!" << std::endl;
        return 0.0;
    }
};

// Derived class for Rectangle
class Rectangle : public Shape {
private:
    double width;
    double height;

public:
    Rectangle(double w, double h) : width(w), height(h) {}

    // Override the virtual getArea() function
    double getArea() const override {
        return width * height;
    }
};

// Derived class for Circle
class Circle : public Shape {
private:
    double radius;

public:
    Circle(double r) : radius(r) {}

    // Override the virtual getArea() function
    double getArea() const override {
        return M_PI * radius * radius;
    }
};


void printShapeArea(const Shape& shape) {
    std::cout << "Shape area: " << shape.getArea() << std::endl;
}

int main() {
    Circle c(3);
    Rectangle r(4, 5);

    printShapeArea(c);
    printShapeArea(r);

    return 0;
}
```

### Чисто виртуални методи. Абстрактни класове

В примера по-горе getArea() на Shape е просто ранна входна точка. Тъй като няма смислена имплементация за този
метод в базовия клас, то можем да **задължим** наследниците да предоставят такава. Това става като направим
съответния метод **чисто виртуален**: `virtual double getArea() const = 0;`.

Клас с чисто виртуален метод се нарича **абстрактен клас**. Той е замислен за деклариране на интерфейс в
дадена йерархия. Той не описва реални обекти в моделирания свят, тоест от него **не може да се създават
обекти**.

---

**Не е добра практика да се използват виртуални методи в конструктори и деструктори!**

### Виртуален деструктор

Нека да имаме горната йерархия, като има и клас `FilledCircle`, който използва динамична памет:

```cpp
class FilledCircle : public Circle {
    char* fillColour;

    //...

    ~FilledCircle() {
        // free mem
    }
}
```

Ако не сме декларирали деструктора на `Shape` като виртуален и унищожаваме обекта през указател към `Shape`,
то няма да се извика този и ще изтече памет. Същото и важи за деструктора на `Circle`.

В курса, **ако имаме клас с виртуален метод, то правим неговия деструктор виртуален!** (В реалния свят
може да има съображения да не искаме да го правим, но в курса ще спазваме това правило)

### Копиране на полиморфни обекти

Когато искаме да направим копие, например в хетерогенен контейнер, на полиморфен обект, то
в базовия клас реализираме виртуален метод:

```cpp
class Shape {
    // ...
public:
    virtual Shape* clone() const = 0;
}
```

Всеки от наследниците го имплементира по свой собствен начин -- `Cicle` създава нов обект за окръжност,
`Rectangle` за правоъгълник и т.н.

---

Възможно е подобно поведение да се направи вътре в контейнера (например), който ще клонира обекта, чрез
така нареченото „преобразуване надолу“ (**downcasting**), използвайки `dynamic_cast` или `static_cast`,
но това **не е добра практика**.

## Задача

Напишете програма, която моделира каталог за мебели. Предлагат се маси, столове и легла, като в бъдеще
може да се появят и други видове.

Мебелите имат следните характеристики:

- маса -- име на модел, височина, широчина, дължина, тип (холова или кухненска);
- стол -- име на модел, височина, широчина, дължина, тип (дървен, метален или пластмасов);
- легло -- име на модел, височина, широчина, дължина.

Всеки мебел има метод, който извежда характеристиките му, както и цена, която се определя по следния начин:

- маса -- `широчина * дължина * 15`;
- стол -- `височина * широчина * 9`;
- легло -- `дължина * височина * 22`.

Каталогът трябва да имплементира следния интерфейс:

```cpp
class AbstractFurnitureCatalog
{
public:
    virtual void create(const Furniture& furn) = 0;
    virtual const Furniture& read(const char* model) const = 0;
    virtual void update(const char* model, const Furniture& newFurn) = 0;
    virtual void remove(const char* model) = 0;
};
```

Реализирайте каталог, който работи в динамичната памет. Погрижете се символните низове да са с точна дължина и да няма течове на памет.

