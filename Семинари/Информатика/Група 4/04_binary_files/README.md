# ООП Семинар 04 -- Файлове с пряк достъп. Двоични файлове

## Файлове с последователен достъп

### Преговор от предния път

- `ifstream`/`ofstream`;
- Проверка дали е успешно отворен/в добро състояние;
- Различни режими за отваряне;
- Различни състояния на потока;
- Затваряне с `close()` когато приключим;

| Операции за четене   | Операции за писане |
| -------------------- | ------------------ |
| `operator>>`         | `operator<<`       |
| `get()`, `getline()` | `put()`            |

### Файлов указател

Можем да си мислим за файловете като последователност от байтове, номерирани от 0 до EOF.
Всеки поток съдържа файлов указател. При четене, той показва позицията, от която ще се чете, а при писане -- къде ще се извърши записването.

Когато отворим файл за четене или писане, по подразбиране този указател е в началото на файла. Когато извършим четене или писане, той се премества
със съответния брой прочетени/записани байтове. Можем да променим началната позиция на указателя: Например, ако отворим файл за писане в append режим 
(`ios::app`), то файловият указател се премества в края на файла.

#### Взимане на текущата позиция

Имаме функциите:

- [`pos_type tellg()`](https://en.cppreference.com/w/cpp/io/basic_istream/tellg), която ни дава текущата поция на указателя в поток за **четене**;
Ако файлът е текстов, текущата позиция за четене е позицията на следващия символ, който ще бъде
прочетен. Ако файлът е двоичен, това е позицията на следващия байт, който ще бъде прочетен.
- [`pos_type tellp()`](https://en.cppreference.com/w/cpp/io/basic_ostream/tellp), която ни дава текущата позиция на указателя в поток за **писане**.

При недобро състояние на потока, и двете функции ще върнат _-1_. Последните букви p/g в имената им идват съответно от get/put.

#### Задаване на позиция на указателя

Аналогично имаме функции за преместване на указателите за четене и писане:

| Функция                                                             | Действие                                                                                  |
| ------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| `basic_istream& seekg( pos_type pos );`                             | Отмества указателя за **четене** на указана **абсолютна** позиция от началото на файла.   |
| `basic_istream& seekg( off_type off, std::ios_base::seekdir dir );` | Отмества указаттеля за **четене** на **относителна** позиция _offset_ спрямо _direction_. |
| `basic_ostream& seekp( pos_type pos );`                             | Отмества указателя за **писане** на указана **абсолютна** позиция от началото на файла.   |
| `basic_ostream& seekp( off_type off, std::ios_base::seekdir dir );` | Отмества указаттеля за **писане** на **относителна** позиция _offset_ спрямо _direction_. |

където:

- _offset_ е цяло число, тоест може да бъде както положително, така и отрицателно;
- _direction_ е една от следните константи:

| Флаг       | Значение                      |
| ---------- | ----------------------------- |
| `ios::beg` | Начало на потока (файла)      |
| `ios::cur` | Текущата позиция на указателя |
| `ios::end` | Края на потока (файла)        |

### Някои проблеми при файловете с последователен достъп

#### Добавяне на дадена позиция

Може ли да се добави нов запис без да се презапише вече съществуваща информация във файла?
Директно, не.

Един начин е всички прочетени до търсената позиция записи да се запишат в нов файл, след което в
този нов файл да се добави новият запис, а след него да се пренесат и останалите записи от
оригиналния файл. Оригиналният файл се премахва, а новият се преименува.
Друг начин е всички записи след исканата позиция да се преместят надолу, подобно на добавяне на
нов елемент в масив.

#### Промяна на запис

Данните се записват и четат последователно. Следователно, първо трябва да се прочетат всички
записи преди търсения. Ако новият и старият запис са с еднаква дължина, то записът може да се
презапише спокойно. В противен случай, има риск да бъдат презаписани и други записи или да
останат частични данни от записа, който трябва да бъде променен.
Едно възможно решение е да се използва нов файл, в който да се пренесат записите от оригиналния
файл, като исканият запис се замени с новия. Оригиналният файл се премахва, а новият се
преименува.

#### Изтриване на запис

Данните се записват и четат последователно. Следователно, първо трябва да се прочетат всички
записи преди търсения.

Може да се прочете следващият запис и да се запише на мястото на записа, който трябва да бъде
изтрит. След това операцията да се повтори за следващия запис. Подобно на изтриване на елемент
на масив, като се изместят всички елементи след него с една позиция наляво. Няма стандартен
начин за намаляване на размера на файл. Това значи, че при подобно изтриване в края на файла ще
остане ненужна, но неизтрита информация.
Може да се използва нов временен файл, в който да се пренесат всички записи без този, който
трябва да бъде изтрит. Оригиналният файл се премахва, а новият се преименува.

---

**Извод:**
Файловете с последователен достъп **не са подходящи**, когато:

- е необходим бърз, директен достъп до даден запис;
- записите трябва да се редактират на място. Операциите изискват обработване на цялото съдържание на файла.

## Файлове с пряк достъп. Двоични файлове

За да имаме пряк достъп, трябва записите във файла да са с еднакъв размер.

Ако разглеждаме цели числа, които искаме да запишем във файл и използваме оператора `<<` за форматиран изход, то всяко от тези числа
ще бъде записано с различен брой цифри. В паметта обаче те са представени с фиксиран брой байтове и ще се възползваме от това,
отваряйки файла в **двоичен** режим.

### Писане в двоичен файл

Използваме функцията `basic_ostream& write( const char_type* s, std::streamsize count )` вместо оператор за форматиран изход. Тя записва _count_
на брой байтове, които се извличат от подадения адрес _s_.

Пример:

```cpp
std::ofstream outputFile("numbers.bin", std::ios::out | std::ios::binary);

if (!outputFile.is_open()) {
  //...
}

int number = 123;

outputFile.write(reinterpret_cast<const char*>(&number), sizeof(number));
```

В случая, `reinterpret_cast` не прави никакви промени по съдържанието на подадения адрес (в примера адресът на _number_), а просто казва на
компилатора да интерпретира байтовете по различен начин -- като данни от типа, указан в триъгълните скоби.
Правим това преобразуване, защото функцията за писане очаква аргумет от тип `const char*`, тоесто последователност от байтове, достъпни само
за четене.

### Четене от двоичен файл

По аналогичен начин чрез `basic_istream& read( char_type* s, std::streamsize count )` четем _count_ на брой байтове от потока в адрес _s_.

Пример:

```cpp
std::ifstream inputFile("numbers.bin", std::ios::in | std::ios::binary);

if (!inputFile.is_open()) {
  // ...
}

int number;

inFile.read(reinterpret_cast<char*>(&number),sizeof(number));
```

### Работа с масиви и структури

#### Масиви

```cpp
int array[10] = {...};

outFile.write(reinterpret_cast<const char*>(array), 10 * sizeof(int));
```

#### Структури

```cpp
struct Student
{
    int id;
    char name[24];
    double grade;
};

Student me = { 10, "Me", 5.78 };

outputFile.write(reinterpret_cast<const char*>(&me), sizeof(me));
```
**Не винаги можем да записваме структури по такъв директен начин!**

### Използване на seek и tell за работа с двоичен файл

Нека имаме информация за студенти (структурата от по-горе), която е записана във файл, и нека факултетните номера на студентите са
последователни и започват от 1.

**Пример 1**: Да се запише информация за студент с факултетен номер 3:

Ако факултетните номера са последователни и започват от единица, това означава, че за да
се достигне до третия запис, трябва да се прескочат първите два. За да се може да се запише
информацията, позицията за запис трябва да бъде променена: 

```cpp
outputFile.seekp(2 * sizeof(Student), std::ios::beg);

outputFile.write(reinterpret_cast<const char*>(&student), sizeof(Student));
```

**Пример 2**: Изтриване на запис:

Когато изтриваме запис в двоичен файл имаме различни възможности:

- Да използваме специално означение, което представлява фиктивен запис. Това дава възможност, ако ни е известен обемът на данните, да имаме
толкова на брой фиктивни записи, които могат да се попълват. По този начин файлът лесно може да бъде поддържан сортиран, както и операциите
за добавяне, редактиране и изтриване на запис са бързи, но има нужда от допълнителна проверка при четене;

- Да изтрием записа, премествайки всички след него с една позиция напред. В този случай времето за изтриване би било по-голямо, но не пазим
„празна“ информация във файла, която заема излишно пространство. Отново имаме и опцията да използваме временен файл при изтриването, както за 
файловете с последователен достъп по-горе.

### Работа с указатели

Нека структурата Студент е дефинирана по следния начин:

```cpp
struct Student
{
    int id;
    char* name;
    double grade;
};
```

Името на студента се съхранява в динамичната памет. В този случай в структурната променлива се съхранява адресът, на който са записани данните.

Какво ще се случи, ако записването на студент във файла се извърши така?

```cpp
outputFile.write(reinterpret_cast<const char*>(&me), sizeof(me));
```

В структурната променлива се съхранява адресът, на който е записано името, т.е. във файла също ще бъде записан адрес. Това обаче е проблем!
**Адресите на паметта не са непременно едни и същи** при всяко изпълнение на програмата и тази информация е безполезна, ако искаме да прочетем
името на студента отново при следващо пускане.

Имаме два варианта:

1. Може да се запише самият низ, заедно с терминиращата 0.
До какво води това? Четенето се усложнява. Начинът, по който са записани данните, определя начина, по който трябва да бъдат прочетени.
Прочита се всичко до срещането на терминиращата 0. След като се определи броят на символите, може да се задели необходимото количество памет.
Низът трябва да бъде прочетен отново, за да се съхрани в паметта. За целта, позицията за четене трябва да се върне отново там, където започва низът.

2. Преди самия символен низ може да се запише броят на символите, след което самите данни.
До какво води това?  Записва се допълнително и размерът. Това ограничава обема на данните, които могат да се
запишат във файла. Низът не може да надвишава като дължина максималната стойност на типа, който се използва за съхраняването на размера.
Много лесно обаче данните могат да бъдат извлечени от файла.

**Остават ли записите с еднакъв размер? Файлът остава двоичен, но запазва ли се прекия достъп до елементите?**

## Задачи

### Задача 1

Напишете програма, която приема име на двоичен файл от командния ред и отпечатва на екрана размера на файла в байтове. Помислете как бихте могли да направите това с помощта на `seek/tell` функциите. Ако такъв файл не съществува или не е подадено име на файл от командния ред, изведете подходящо съобщение.

### Задача 2

След поредния невзет изпит Радо сериозно започва да се замисля дали ФМИ е за него... Вътрешно той знае за себе си, че не е роден да става програмист, а че неговото призвание е изкуството. Радо е голям почитател на обработването на изображения - да отрязва конкретни части от тях, да ги преоразмерява, да добавя ефекти и т.н. Покажете на Радо, че може да съчетава изкуството с програмирането, като му помогнете да си напише собствена програма, която прави един простичък, но полезен ефект - превръща цветни изображения в черно-бели такива. (*за да звучи по-fancy - от RGB в Grayscale*).

Тошко - най-добрият приятел на Радо, му подсказал, че най-лесно би постигнал това, като обработва `bmp` изображения. Той му обяснил, че това всъщност не са нищо повече от обикновени двоични файлове. Като един истински приятел, Тошко дори разяснил в подробности какви са особеностите на `bmp` изображенията:
- Състоят се от **две** основни части - служебна информация за изображението (**метаданни**) и матрица от пиксели (**практическото съдържание на изображението**)
- Не ни е необходима цялата информация от метаданните; трябват ни само:
    - размерът на файла (**позиция 2**, *4 байта*)
    - позицията, на която започва матрицата от пиксели (**позиция 10**, *4 байта*)
    - брой колони на матрицата от пиксели (**позиция 18**, *4 байта*)
    - брой редове на матрицата от пиксели (**позиция 22**, *4 байта*)
- Всеки пиксел се състои от *3 байта*, по един за всеки от основните три цвята - червено, зелено и синьо (**RGB**) (стойности между **0** и **255**)
- Всеки ред има **padding**, допълващ броя на байтовете на всеки ред да бъде число, делящо се на **4**
- Информацията в padding-a се игнорира при визуализиране на изображението

За да превърне RGB пиксел в Grayscale такъв, Радо попитал своята приятелка Габи, която е специалистка в алгоритмите. За да покаже колко много знае, тя му дала списък със 100 различни алгоритми:
- `Grayscale Value = (R + G + B) / 3`
- `Grayscale Value = (max(R, G, B) + min(R, G, B)) / 2`
- `Grayscale Value = 0.2126 * R + 0.7152 * G + 0.0722 * B`
- `Grayscale Value = 0.30 * R + 0.59 * G + 0.11 * B`
- *списъкът продължава с още 96 алгоритъма...*

Тъй като алгоритмите практически постигат почти един и същи резултат, няма особено голямо значение кой от тях ще избере Радо.

За да бъдете от истинска помощ на Радо, приемете две имена на двоични файлове на изображения в `bmp` формат от командния ред - първият трябва да бъде на съществуващо цветно RGB изображение, а във втория трябва да бъде запазеното конвертираното Grayscale изображение. Използвайки информацията, предоставена Ви от Тошко и Габи, реализирайте алгоритъма за конвертиране чрез подходящи структури и функции.
