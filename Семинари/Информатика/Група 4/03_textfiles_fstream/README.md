# ООП Семинар 03 -- Потоци и файлове. Текстови файлове

## Потоци

Потокът е абстракция, която представя последователност от данни, които ще получаваме във времето. Използваме ги за връзка между програмата и входни/изходни устройства или файлове.

Вече в курса сме ползвали потоци:

```cpp
#include <iostream>

int main() {
    int number;
    std::cout << "Enter a number: ";
    std::cin >> number;
    std::cout << "You entered: " << number << std::endl;

    return 0;
}
```

[Input/output library в cppreference.com](https://en.cppreference.com/w/cpp/io)

## Файлови потоци

Днес ще разглеждаме файлове с **последователен достъп**, т.е. такива при които обработката започва от началото към края и данните се разглеждат в реда, в който са записани. При тези файлове обикновено различните данни имат различен размер.

Според операциите, които могат да бъдат извършвани, имаме три вида файлове:

- за четене;
- за писане;
- за четене и писане.

### Какво са файловите потоци?

В езика C++ има три вида фаЙлови потоци, които могат да се използват след включването на заглавния файл `<fstream>`

- ifstream -- предназначен за връзка с файлове, от които се четат данни;
- ofstream -- предназначен за връзка с файлове, в които се записват данни;
- fstream -- предназначен за връзка с файлове, с които ще се извършват както входни, така и изходни операции, т.е. файлове за четене и писане.

За разлика от `cin` и `cout`, които са предварително дефинирани и свързани със съответните устройства, тоест са готови за използване, файловите потоци трябва да бъдат свързани с файл явно.

### Отваряне за четене и четене от файл

```cpp
#include <iostream>
#include <fstream>

int main()
{
    std::ifstream inputFile;
    inputFile.open("hello.txt");
    // or:
	// std::ifstream inputFile("hello.txt");

	if (!inputFile.is_open()) {
		std::cout << "Error!" << std::endl;
		return -1;
	}

    // Read two integers from the file
	int a, b;
	inputFile >> a >> b;

	inputFile.close();
}
```

Освен чрез оператора `>>` можем да използваме и други функции за четене когато ни е нужен повече контрол: Виж `get()` и `getline()` [тук](https://en.cppreference.com/w/cpp/io/basic_istream).

### Запис във файл

По аналогичен начин можем да отворим файл за писане и да запишем данни вътре:

```cpp
#include <iostream>
#include <fstream>

const char FILE_NAME[] = "myFile.txt";

int main()
{
	std::ofstream file(FILE_NAME);

	if (!file.is_open()) {
		std::cout << "Error!" << std::endl;
		return -1;
	}

	int a = 3;
	int b = 10;

	file << a << " " << b << " " << a + b << std::endl;

	file.close();
}
```

### Възможни начини за отваряне

Какво би станало, ако в горния пример отворим файл, в който вече има записана инфромация? Ще бъде презаписан. Затова има различни режими за достъп до файл:

- <https://en.cppreference.com/w/cpp/io/ios_base/openmode>

| Режим       | Значение                                                                                                                                                    |
| ----------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ios::in     | Отваря файл за извличане. Подразбира се за ifstream.                                                                                                        |
| ios::out    | Отваряне на файл за вмъкване. Допуска се вмъкване на произволни места във файла. Ако файлът съществува, съдържанието се изтрива. Подразбира се за ofstream. |
| ios::ate    | Отваря за вмъкване и установява указателя за писане в края на файла. Допуска вмъкване на произволни места.                                                  |
| ios::app    | Отваря за вмъкване и установява указателя за писане в края на файла.                                                                                        |
| ios::trunc  | Ако файлът съществува, съдържанието се изтрива.                                                                                                             |
| ios::binary | Превключва режима от текстов в двоичен.                                                                                                                     |

Тези режими на работа са битови флагове, за да ги комбинираме използваме побитовата операция или `|`.

Допъллнителни материали за побитови операции:
- <https://en.cppreference.com/w/cpp/language/operator_arithmetic> в секцията „Bitwise logic operators“;
- <https://www.informatika.bg/lectures/bitwise-operations>

### Състояние на потока

В зависимост от това дали последната операция над потока е била успешна, поток може да бъде в 4 основни състояния, които се описват с отделни битове.

- **good**: Потокът е в добро състояние, ако последната операция е била успешна. Това е най-общият флаг. За да е вдигнат, никой от останалите флагове не трябва да е вдигнат. Състоянието може да се провери чрез: `fileStream.good();`
- **bad**: Потокът е в състояние bad, ако последната операция не е успешна. Възникнала е критична грешка по време на работата с потока, от която потокът не може да се възстанови. Например при хардуерен проблем.
  Състоянието може да се провери с `fileStream.bad()`. Когато потокът е в състояние bad, той не е в състояние good, но състоянието bad не е противоположно на състоянието good.
- **fail**: Потокът е в състояние fail, ако последната операция не е успешна. Когато потокът е в състояние fail, той не е в състояние good. Пример за това е грешен формат на данните. Например очакваме да се прочете число, но от текущата позиция не може да се разпознае такова.
  С определени действия, състоянието на потока може да бъде възстановено и работата с него да продължи. Състоянието може да се провери чрез `fileStream.fail()`. Обикновено този флаг се вдига когато е вдигнат флага bad.
- **eof**: Флагът за край на файл eof (end of file) се вдига, ако е направен опит за четене след последния символ, а не при прочитането на последния символ. Заедно с него се вдига и флага fail, защото се търсят някакви данни, но такива не се откриват и операцията пропада. `fileStream.eof();`

Бележки:

- Ако състоянието на потока не е добро, то остава такова, докато не бъде възстановено. За да се възстанови обратно в състояние good, може да се използва функцията clear(). `fileStream.clear()` функцията сваля всички флагове за грешка и възстановява състояние good.
- Ако състоянието на потока не е добро, (почти) всички операции, които се прилагат върху него ще бъдат неуспешни. Програмата ще премине през указаните операции, но няма да произведе никакъв резултат.
- При обхождане на даден файл, най-добре е да не се използва проверката за достигане на край на файл като условие в цикъл. Така няма да се провери за състояния bad или fail, получено поради друга причина. Най-добре е в условието на цикъла да се проверява дали състоянието на потока е good. Също при получаване на състояние fail, ако за програмата има значение по каква причина то е възникнало, трябва да се изследват останалите състояния.
- Затварянето на файл не изчиства състоянието на потока. Ако файлът е изчетен докрай и трябва да се изчете повторно със същия поток, преди това трябва да се изчисти неговото състояние.

#### Други начини да се провери състоянието на потока

Потокът може да бъде преобразуван неявно до булева стойност. Стойност `true` е съответствие на добро състояние на потока.

```cpp
if(inputFile) // <=> if(inputFile.good())

if(!inputFile) // <=> if(!inputFile.good())

// Докато потокът е в добро състояние, чети. Допълнително, ако искаме да сме сигурни, че сме прочели всичко,
// трябва да проверим .eof()
while(inputFile >> number) {
  //...
}
```

## Задачи

### Задача 1

Напишете програма, която отпечатва собствения си код.

### Задача 2

Напишете проргама, която извежда на екрана броя на новите редове в даден текстови файл.

### Задача 3

Реализирайте програма, която приема името на даден файл и създава копие на файла, в което всяко срещане на зададена от потребителя дума е заменено с друга дума, също подадена от потребителя.

За улеснение приемете, че думите във файла няма да са по-дълги от 100 символа.

_Допълнение: Използвайте аргументи при извикване на програмата за задаване на входните данни._

### Задача 4

Да се реализира програма, която работи с инфромация за служителите в дадена компания. Всеки служител има служителски номер, име, фамилия и ръководител. Служителските номера са цели положителни числа, а имената са с дължина не повече от 100 символа.
Програмата трябва да предоставя следните възможности:

1. Записване на нов служител във файла, без да се променя информацията за другите;
2. Прочитане на всички служители от файл, при което се извежда информация за тях на екрана;
3. Извеждане на инфромацията за конкретен служител по даден номер;
_4. Допълнение: Промяна на данните на даден служител по даден служителски номер._

