# ООП Семинар 06:  Класове и обекти -- жизнен цикъл. Конструктори и деструктори. Инициализация.  Изключения.

## Жизнен цикъл на обект

Независимо дали са глобални, локални статични, локални автоматични или динамични, за всички променливи/обекти в някакъв
момент се заделя памет и те се инициализират -- когато влязат в съответната област на видимост (scope).

Когато се достигне края на съответния scope или се освободи динамичната памет, обектите се разрушават и паметта се
освобождава.

[*Допълнително припомняне какво е статично, глобално и т.н.*](https://stackoverflow.com/questions/13415321/difference-between-static-auto-global-and-local-variable-in-the-context-of-c-a)

## Конструктори

От миналия път...

Конструкторът е специална член-функция на класа, която се извиква автоматично при създаването
на обект от този клас. Конструкторът се извиква един-единствен път при създаването на обекта.

Конструкторите се използват, за да инициализират всички член-данни на обекта с подходящи,
валидни стойности, подадени от потребителя. Общо казано, конструкторите подготвят обекта за
работа. Това може да означава и да се задели динамична памет, да се отвори файл, да се направи
връзка с база от данни и др.

### Конструктор по подразбиране

Ако в класа не дефинираме изрично конструктор, то *компилаторът генерира* конструктор по подразбиране.

#### Предефиниране на конструктора по подразбиране (конструктор без параметри)

```cpp
class Test {
    int a;
    int b;

public:
    Test() {
        a = 2;
        b = 3;
    }
}
```

#### Извикване на default ctor. Default vs Value Initialization

```cpp
Test t1(); // !!!

Test t2;
Test t3 {};
```

Редът с `t1` е **грешен**! Не се извиква конструкторът по подразбиране, а се декларира функция с име `t1`, която не получава
никакви параметри.

И в двата случая за `t2` и `t3` ще се извика предефинираният конструктор по подразбиране.

Ако обаче **нямаше конструктор по подразбиране**, то резултатът щеше да е **различен**:

- `t2` ще е инициализиран със случайни стойности;
- `t3` ще бъде с нулирани член данни;

---

Аналогично се случва и с други типове:

```cpp
int a;
int b {};

int arr1[10];
int arr2[10]{};
```

Доста по-подробна информация (която не е непременно нужна в курса):

- <https://en.cppreference.com/w/cpp/language/default_initialization>
- <https://en.cppreference.com/w/cpp/language/value_initialization>

### Конструктор с параметри

```cpp
Test(int a, int b) {
    this->a = a;
    this->b = b;
}
```

Както всяка друга функция и конструкторът може да има параметри по подразбиране:

```cpp
Test(int a, int b = 0) {
    this->a = a;
    this->b = b;
}
```

### Копиращ конструктор

Това е специален конструктор, който се извиква когато създаваме обект чрез вече създаден друг от същия клас.

Ако не дефинираме изрично такъв, то компилаторът ще направи* такъв по подразбиране, който копира едно към едно полетата.

Примери за извикване:

```cpp
Test t1(2,3);
Test t1_copy(t1); // or t1_cpy = t1;


void fun(Example ex) {
...
}


Example fun2() {
    ...
    return result;
}
```

\*Забележка: В последният случай няма да се извика копиращ конструктор, ако в класът има дефиниран move
конструктор (за тях евентуално по-нататък). Също, ако класът съдържа член-данни които не могат да бъдат
копирани (например копирането е забранено или конструкторите са недостъпни, или пък са повече от един и не може
да бъде еднозначно избран един) няма да се генерира копиращ конструктор по подразбиране.

**Задължително дефинираме собствен копиращ конструктор когато използваме динамична памет**:

```cpp
class Student {
    char* name;
    double grade;
    ...
}

Student::Student(const Student& other) {
    this->grade = other.grade;
    this->name = new char[strlen(other.name) + 1];
    strcpy(this->name, other.name);
}
```

### Допълнително за List Initialization

<https://en.cppreference.com/w/cpp/language/list_initialization>

## Константни член-функции и член-данни

### Константни член-функции

Както за всеки друг тип, така и за нашите класове може да правим обекти, които са константни. Позволените
операции върху него са само тези, които са маркирани като константни:

```cpp
void print() const;
```

В такава функция не може да се променят член-данните и в нея могат да се използват само други константни методи.

Понякога се налага да се дефинират две функции -- едната константна и едната не:

```cpp
int& DynamicArray::at(std::size_t index);
const int& DynamicArray::at(std::size_t index) const;
```

### Константни член-данни

Константните полета могат да бъдат инициализирани само веднъж когато се декларират. Когато конструкторът
започне да работи, за тях е заделена памет и те са инициализирани. Тоест имаме проблем в тялото на конструктора
когато се опитаме да им присвоим стойност:

```cpp
class Example {
    const int c;
    int var;

public:
    Example(int c, int var) {
    this->c = c; // !!!
    this->var = var;
}
```

Затова използваме т.нар. инициализиращ списък:

```cpp
Example::Example(int c, int var)
    : c(c), var(var) {
    //...
}
```

Внимание: Полетата се инициализарат **в реда, в който са декларирани** в дефиницията на класа, а **не** в реда
на написването им в инициализиращия списък!

---

Още за конструкторите и member initializer list вижте [тук](https://en.cppreference.com/w/cpp/language/constructor).

## Деструктор

Специален метод, който се извиква автоматично при излизане от област на видомист или извикване на delete.
Той се грижи за почистването след обекта, например да освободи заделената динамична памет.

Ако използваме само „обикновени“ полета, то няма нужда да дефинираме деструктор -- компилаторът ще направи
системен такъв. Ако използваме **някакъв вид ресурс**, като динамична памет, файл и т.н., то трябва да освободим
този ресурс като дефинираме деструктор.

```cpp
Student::~Student() {
    delete[]  this->name;
}
```

## Операция за присвояване

Можем да правим промяна на създаден обект чрез друг обект, използвайки операторът за присвояване.

Както и за другите методи по-горе, ако класът ни е тривиален, то няма нужда от изрично дефиниране.
Ако обаче използваме ресурс, например **динамична памет**, задължително го правим:

```cpp
Student& Student::operator=(const Student& other) {
    if (this != &other) {
        // Copy stuff only when not self-assigning
        delete[] this->name;

        this->name = new char[strlen(other.name) + 1];
        strcpy(this->name, other.name);

        this->fn = other.fn;
        this->grade = other.grade;
    }

    return *this;
}
```

## Rule of 3. Голяма четворка

### Rule of 3

Rule of three казва, че ако даден клас се нуждае от изрично дефиниран **деструктор**, **копиращ конструктор** или
**оператор за присвояване**, то той най-вероятно се нуждае и от **трите едновременно**.

#### Голяма четворка

Голямата четворка се състои от методите в rule of three, заедно с конструктор по подразбиране.

### Допълнително за Rule of 5 и Rule of 0

<https://en.cppreference.com/w/cpp/language/rule_of_three>

## Изключения

Изключенията са механизъм за известяване при настъпил логически проблем. Нека разгледаме примера:

```cpp
double divide(int x, int y) {
    return x / y; // No check for division by zero
}

// It's cumbersome and hard to read this way
bool divide2(int x, int y, double& result) {
    if(y == 0) {
        return false;
    }

    return x / y;
}
```

В случая използването на функцията за деление е допълнително усложнено, което от една страна е неудобно, от друга прави кодът по-труден за четене
(особено ако започнем да разглеждаме по-сложни примери).

В определени ситуации пък изобщо не можем да връщаме някакъв резултат -- например в конструктор на обект. Как сигнализираме, че са подадени невалидни
данни?

### Хвърляне на изключение

Хвърлянето на изключение става чрез `throw`. Например:

```cpp
throw "Invalid argument: Division by zero!"; // String
throw INVALID_INDEX; // Integer
throw std::out_of_range("Invalid array index"); // Object
```

### Прихващане на изключение

Прихващане на изключение:

```cpp
try {
    somethingThatMightThrow();
}
catch (...) {
    handleTheException();
}
```

#### По-подробен пример за хвърляне и прихващане на изключения

Пример от доц. Петкова:

```cpp
#include <iostream>
#include <stdexcept>

void throwException() {
    int choice;
    std::cout
            << "What do you want to throw?\n"
            << " [1] char\n"
            << " [2] int\n"
            << " [3] double\n"
            << " [4] std::exception object\n"
            << " [5] std::out_of_range object\n"
            << "Your choice: ";
    std::cin >> choice;
    switch (choice) {
        case 1: throw '!';
        case 2: throw 5;
        case 3: throw (double) 5.5;
        case 4: throw std::runtime_error("Something happened!");
        case 5: throw std::out_of_range("Something is out of range!");
        default:
            throw std::logic_error("A number between 1 and 5 was expected!");
    }

    std::cout << "Will this line ever be executed? Never!\n";
}

// външна функция, която обработва само два вида изключения
void caller() {
    try {
        // дори и функцията да хвърли изключение от тип char,
        // няма да бъде направено преобразуване до int
        // не се осъществява неявно преобразуване за примитивните типове данни
        // единствено, ако имаме йерархия от изключения,
        // изключение от производен тип може да бъде прихванато от catch блок,
        // в който е указан базовият тип
        // ако в catch блока трябва да бъдат изброени и производните типове, и базовия,
        // то базовият тип трябва да бъде накрая
        throwException();
    } catch (int ex) { std::cout << "Caught an int: " << ex << std::endl; } catch (double ex) {
        std::cout << "Caught a double: " << ex << std::endl;
    }
}

int main() {
    try {
        caller();
    }
    // ако изключението е обект, то трябва да бъде прихванато по псевдоним,
    // за да се избегне излишното му копиране
    catch (const std::out_of_range &ex) {
        std::cout << "Caught a std::out_of_range: " << ex.what() << std::endl;
    }
    // std::out_of_range преди std::exception, защото е производен клас
    // в противен случай изключение от тип std::out_of_range ще бъде прихването
    // в catch блока на std::exception
    catch (const std::exception &ex) {
        std::cout << "Caught a std::exception: " << ex.what() << std::endl;
    }
    // специален тип catch блок, който се използва за прихващане на всякакъв вид изключения,
    // ако се използва трябва да стои най-отдолу, като последен блок
    catch (...) {
        std::cout << "Caught something the rest have failed to catch... but what is it?\n";
    }
}
```

### Изключение в конструктор

```cpp
class Example {
    int a;
    char* cstr;

    Example(int a, char* name) {
        this->name = new char[strlen(name) + 1];
        strcpy(this->name, name);

        if(a == 0) // If a is invalid
        {
            delete[] this->name;
            throw "Invalid argument!";
        }
        this->a = a;
    }
}
```

Когато имаме заделени ресурси, трябва да ги **освободим преди да хвърлим изключение**. Когато се хвърли изключение, обект няма да бъде създаден.

В примера горе, може да се направи по-лесно, като първо се обработи валидността на `a` преди да се заделя памет, но невинаги можем да правим
такива оптимизации.

### Изключение в деструктор

Изключенията не трябва да напускат деструктора. Ако възникне **изключение в деструктор, то трябва да се прихване и обработи**, като ако е възможно
да се освободят всички ресурси.

Ако не прихванем изключение в деструктор, то при превъртането на стека няма да е възможно съответното извикване на деструкторите 
на локалните променливи. Така програмата ще бъде прекъсната веднага и няма да има възможност за обработка.

## Exception safety

Има 4 нива на гаранции, които се дават при работа с изключения:

### No throw guarantee

Съответната операция ще бъде винаги успешна. Дори и да възникне изключение, то ще бъде обработено и външния свят няма да разбере за него.
Такава функция е деструкторът.

### Strong exception safety guarantee

Операциите могат да не са успешни, но няма да имат странични ефекти и състоянието на съответния обект ще остане валидно и **непроменено**.

Например, ще проверим дали можем да заделим памет при присвояване на името на студент, преди да променим оценката в извикване на оператор за присвояване. Ако не успеем да заделим, то няма да променяме нищо и няма да изтичат ресурси.

### Weak exception safety guarantee

Операциите могат да не са успешни, като може да бъдат частично изпълнени и състоянието на съответен обект ще остане **валидно, но може да бъде променено**.
Както и в горните случаи, тук **няма изтичане на ресурси**.

За разлика от горния пример, тук не гарантираме, че оценката на студента няма да бъде променена, а само, че няма да има изтичане на ресурс.

### No guarantee

Не даваме никакви гаранции за операциите и състоянието на обектите.

---

## Задача

Започнали сте да правите приложение за музика. В него има песни. Създайте клас, който представя песен: Всяка се задава
чрез име, изпълнител и продължителност (минути и секунди).

Ще трябва да помислите за подходящи начини за създаването на песни, така че те да са удобни за работа. Реализирайте
подходяща валидация, като се възползвате от изключения.

Обектите от този тип ще трябва да се копират многократно (например ако в приложението има функция за плейлист) -- кое
от горните правила 0/3/5 трябва да бъде приложено?

В допълнение, би било удобно да има подходящи getter-и и setter-и за работа с обектите.

*Забележки*: 
- Текстовите полета трябва да бъдат с точен размер;
- Погрижете се за правилното използване на динамична памет и не допускайте течове;
- Целете се към максимално спазване на чист код;
- Не е позволено използването на `std::string`;
- Позволено е използването на библиотеките `<cstring>`, `<fstream>` и `<cassert>`.
