# ООП Семинар 10: Още за предефиниране на оператори. Приятели

## [Приятели](https://en.cppreference.com/w/cpp/language/friend)

- Чрез `friend` даваме достъп на друг клас или външна функция достъп до private или protected член-данни и член-функции
на даден клас;
- В някакъв смисъл това чупи енкапсулацията, но е полезно в някои случаи;
- Приятелството не е транзитивно -- ако клас А е приятелски на Б, а Б е приятелски за В, то не е вярно, че А е приятелски за В (освен ако изрично не е декларирано противното);
- Приятелството не се наследява;
- Приятелството не е симетрично -- ако клас А е приятелски на Б, то не значи, че Б е приятел на А.

## Още за предефинирането на оператори

### Кога да бъде член-функция, кога външна (и може би приятелска) функция?

#### Член-функции

- имаме неявен параметър `this` в него;
- подходящ за оператори, които **променят състоянието на обекта**, например тези за присвояване (`=`, `+=`,...) или пък
операторите за инкрементиране/декрементиране (`++`, `--`);
- **изискване** при някои оператори, например `=`, `[]`, `()`, `->`;
- не е подходящ когато имаме миксирани типове (най-вече за левия операнд), например `int + MyClass`.

#### Външни функции

- всички операнди се подават явно като параметри;
- подходящ за **симетрични операции**, например аритметичните такива;
- подохдящ за **операции с миксирани типове** -- `int + MyClass` или пък извеждане към поток;
- няма директен достъп до private членовете.

##### Приятелски външни функции

За да се даде достъп до операторите (или каквито други функции са нужни) до скритите членове на класа, тези
функции се обявяват за приятели.

- Най-често това се ползва при предефиниране на операторите `<<` и `>>` за **вход и изход**.

### Пример

```cpp
#include <iostream>

class Point {
private:
    int x;
    int y;

public:
    Point(int x = 0, int y = 0) : x(x), y(y) {}

    Point operator+(const Point& other) const {
        return Point(x + other.x, y + other.y);
    }

    bool operator==(const Point& other) const {
        return (x == other.x && y == other.y);
    }

    friend std::ostream& operator<<(std::ostream& os, const Point& p) {
        os << "(" << p.x << ", " << p.y << ")";
        return os;
    }

    friend std::istream& operator>>(std::istream& is, Point& p) {
        // Expect input in the format (x, y)
        char openParen, comma, closeParen;
        is >> openParen;
        if (openParen == '(') {
            is >> p.x >> comma;
            if (comma == ',') {
                is >> p.y >> closeParen;
                if (closeParen == ')') {
                    return is; // Return the input stream if successful
                }
            }
        }
        // If the input format is incorrect, set the failbit of the stream
        is.setstate(std::ios::failbit);
        return is;
    }

    Point& operator++() {
        ++x;
        ++y;
        return *this;
    }

    Point operator++(int) {
        Point temp = *this;
        ++x;
        ++y;
        return temp;
    }

    int getX() const { return x; }
    int getY() const { return y; }
};

int main() {
    Point p1;
    std::cout << "Enter a point in the format (x, y): ";
    std::cin >> p1;

    if (std::cin.good()) {
        std::cout << "You entered: " << p1 << std::endl;
    } else {
        std::cerr << "Invalid input format." << std::endl;
    }

    return 0;
}
```

## Задачи

### Задача 1

Разширете кода от миналия път, като реализирате възможност за:

1. Класът `Money` да притежава оператори `<<` и `>>` за вход и изход.
2. Класът Money да бъде събиран с числа от тип `int` и `double` по комутативен начин, тоест да е възможно
`int + Money`, `Money + int`, `double + Money` и `Money + double`. При събирането, числото се прибавя към сумата.
3. Класът `Money` да може да бъде преобразуван към `int` и `double`.

При направата на исканите функционалности съобразете какви промени са нужни по другите класове, така че да
улесните своята работа и да спазвате добрите практики.

*Допълнително, реализирайте вход и изход за класовете за клиент и банка.*

### Задача 2

Имплементирайте оператор `[]` за банката, който връща клиентът, който се намира на съответния индекс в банката.

### Задача 3 (Още упражнение за вкъщи)

Реализирайте клас **ComplexNumber**, който ще се използва за работа с комплексни числа. Предефинирайте оператори със следната функционалност:

- Събиране на комплексни числа.
- Изваждане на комплексни числа.
- Умножение на комплексни числа.
- Деление на комплексни числа.
- Вход и изход от потоци.

```cpp
int main()
{
	ComplexNumber c;
	cin >> c;

	ComplexNumber c2;
	cin >> c2;

	ComplexNumber result = c2 / c;

	cout << result << endl;
}
```
