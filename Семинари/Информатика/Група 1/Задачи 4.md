Реализирайте следните класове с фокус върху *коректна работа с паметта* и **предефиниране на оператори**:

### Задача 1

Клас `DynamicArray`, който да реализира динамичен масив, който може да съхранява произволен брой елементи от тип `int`. За класа реализирайте нужното за коректен жизнен цикъл и добра капсулация, а също и следните оператори:
- версия на оператор за присвояване `=`, получаваща аргумент `int*` и копиращ толкова елемента, колкото е имало в обекта;
- оператор за индексиране `[]`. Трябва да позволява промяна на елемент;
- оператори за сравнение (еквивалентност и наредба). Използвайте лексикографска наредба;
- оператори `+` за добавяне на елемент в края на масива;
- оператори `+` за конкатенация на два масива;
- оператори `-` с аргумент число, които премахват всяко срещане на това число в масива;
- оператори за вход и изход в поток;
- функционален оператор `()` с аргумент `int`, който играе роля на търсене - връща индекса на първото срещане на аргумента си.
За класа реализирайте итератор.

### Задача 2

Клас `BoolArray`, който да реализира динамичен масив от `bool` (само стойности `true`/`false`). Всеки елемент трябва да заема един бит. За класа реализирайте следните оператори:
- оператор за присвояване от `uint32_t`, който заменя масива с битовото представяне на аргумента си.
- оператор за индексиране `[]`. Трябва да позволява промяна на елемент;
- оператори за сравнение (еквивалентност и наредба). Използвайте лексикографска наредба;
- оператори `+` за добавяне на елемент в края на масива;
- оператори `+` за конкатенация на два масива;
- оператори за вход и изход в поток;
- оператор за преобразуване към `uint32_t`, който връща число, съставено от битове, равни на първите 32 булеви стойности от масива. Ако са по-малко, числото да се допълни с 0 (`false`).
За класа реализирайте итератор.

### Задача 3

Клас `Matrix`, който представлява матрица от числа с плаваща точка (`float`).
За матрицата реализирайте всякакви оператори, за които се сетите по спомени от ЛА :) За индексиране направете помощен тип `MatrixIndex`, който да е двойка индекси и него подавайте на оператор `[]`.

### Задача 4

Реализирайте клас `OopString`, който да наподобява максимално [`std::string`](https://en.cppreference.com/w/cpp/string/basic_string) като интерфейс.

### Задача 5

Клас `RLE`, който да представя символен низ, но вътрешното представяне да като последователност от двойки от символ и повторения. Така например низа `'aaabbacbbsssss'` трябва да е съхранен като:
```
{ ('a', 3), ('b', 2), ('a', 1), ('c', 1), ('b', 2), ('s', 5) }
```
Реализирайте поведение максимално близко до `std::string`, като съобразите вътрешното представяне.

### Задача 6

Клас `Base64`, който реализира [base 64 кодиране](https://en.wikipedia.org/wiki/Base64) на масив от байтове.
Създавате класа чрез масив от байтове, но за външния свят данните трябва да изглеждат като base64 низ.
Реализирайте функции като `setData`, `appendData`, ... с които да можете да променяте и последователността от байтове. Добавете оператори за индексиране, вход и изход и добавяне в края, които да работят със символното представяне.
Реализирайте оператор за преобразуване към вашия клас `ОopString`, който да връща копие на кодираната версия.
